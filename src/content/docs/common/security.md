---
title: 前端安全
---

## 请解释一下什么是 XSS，有哪些类型，以及如何防御

**XSS（Cross-Site Scripting，跨站脚本攻击）** 是一种常见的 Web 安全漏洞。攻击者通过在网页中注入恶意脚本（通常是 JavaScript），让这些脚本在其他用户的浏览器中执行，从而达到窃取数据、劫持会话、伪造请求等目的。

### XSS 的类型

#### 存储型 XSS（Stored XSS）

恶意代码被存储在服务器数据库或文件里，其他用户访问页面时，脚本被取出并执行。

例如：在评论区输入 `<script>alert("XSS")</script>`，被存入数据库，之后所有访问评论的人都会弹窗

#### 反射型 XSS（Reflected XSS）

恶意脚本通过 URL 参数直接传递。服务器未做过滤，原样返回到页面。用户点击恶意链接时，脚本立即执行。

例如：`https://example.com/search?q=<script>alert('XSS')</script>`

#### DOM 型 XSS（基于 DOM 的 XSS）

漏洞出在前端 JavaScript 代码本身。前端直接把用户输入写进 DOM，而没有经过安全处理。

例如：`document.body.innerHTML = location.hash;`

### 常见危害

- 窃取用户 Cookie/session（劫持登录状态）
- 伪造用户请求（CSRF 配合 XSS 更危险）
- 钓鱼攻击（修改页面内容，引导用户输入账号密码）
- 挂马（注入恶意脚本，进一步下载木马或挖矿程序）

### 防御措施

1. **输入过滤与验证**
    - 对用户输入进行校验，过滤掉特殊字符（如 `< > " ' /`），例如使用 DOMPurify、xss 等库
    - 尽量使用白名单机制，只允许特定格式的内容
2. **输出编码**
    - 将输出到 HTML、JS、URL 的内容进行编码，防止浏览器误解析为代码
    - 例如：`<` 编码为 `&lt;`，`>` 编码为 `&gt;`
3. **避免使用危险的 API**
    - 使用 `textContent` 替代 `innerHTML`
    - 避免使用 `eval()` 等动态执行代码的函数
4. **设置安全响应头**
    - 使用 `Content-Security-Policy (CSP)` 限制资源加载来源
    - 设置 `X-XSS-Protection: 1; mode=block` 启用浏览器内置防护
5. **使用 HttpOnly Cookie**
    - 防止 JavaScript 访问 Cookie，降低会话劫持风险
6. **定期安全测试**
    - 进行代码审查、自动化扫描或渗透测试，及时发现并修复漏洞

## 什么是 CSRF

TODO:

## 什么是 CSP

**CSP（Content Security Policy，内容安全策略）** 是一种由浏览器强制执行的安全机制，用于防止跨站脚本攻击（XSS）、数据注入攻击等。它通过指定哪些资源（如脚本、样式、图片等）可以被加载，来减少攻击面。

TODO:

## 什么是同源策略？

**同源策略（Same-Origin Policy）** 是浏览器的一种核心安全机制，核心目的是 *防止恶意网站通过脚本窃取或篡改其他网站的敏感数据*。它的核心思想是：只有同一“源”（协议+域名+端口）的网页或脚本才能互相访问资源。意义包括：

- 防止跨站脚本攻击（XSS）：如果恶意网站能随意读取其他网站的数据（如 Cookie、LocalStorage），用户的隐私和账户安全将受到威胁。
- 阻止恶意行为：例如，防止恶意脚本在用户不知情的情况下，以用户身份向其他网站（如银行、邮箱）发起请求（如转账、删除邮件等）。

同源策略虽然安全，但也限制了合法的跨域请求。有时，开发者希望安全地允许跨域请求。**CORS（跨源资源共享，Cross-Origin Resource Sharing）** 就是浏览器提供的一种受控的跨域访问方案。

## 跨域问题是什么？有哪些解决方案？

跨域问题是由于浏览器的 **同源策略** 引发的安全限制，当请求的**协议**、**域名**、**端口** 任一与当前页面不同时，浏览器会拦截响应数据。解决这一问题的核心是通过合法手段绕过或放宽这一限制。

解决方案包括：

- **CORS（跨域资源共享）** 是最标准的方案，通过后端设置响应头（如`Access-Control-Allow-Origin`）明确允许特定域的请求，支持所有 HTTP 方法，但需要前后端协作。
- 若前端可控，可通过**代理服务器**（如 Nginx 或开发环境的 Webpack 代理）转发请求，将跨域转化为同源请求。
- 对于老旧系统，**JSONP** 利用`<script>`标签的特性实现跨域，但仅支持 GET 且安全性较低。
- **WebSocket** 协议天然不受同源策略限制，适合实时通信场景。此外，通过 **PostMessage** 结合`iframe`可实现跨页面通信。
- **修改 document.domain** 则适用于主域相同的子域间交互。

实际选择时，优先考虑**CORS**（需后端支持）或**代理服务器**（前端可控场景），遗留系统可尝试 JSONP，需注意安全性及适用场景限制。
